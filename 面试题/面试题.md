# 面试题

## Android题

### 1. Android系统架构？

答案：
Android 架构:Linux Kernel(Linux内核)
Hardware Abstraction Layer(硬件抽象层)
Libraries(系统运行库或者是c/c++ 核心库)
Application Framework(开发框架包 )
Applications(核心应用程序)

5层，分别是Linux内核层，硬件抽象层，C/C++核心库层，Framework层，应用层

### 2. 线程方法：

1. `sleep`会使当前线程睡眠指定时间，不释放锁
2. `yield`会使当前线程重回到可执行状态，等待cpu的调度，不释放锁
3. `wait`会使当前线程回到线程池中等待，释放锁，当被其他线程使用notify，notifyAll唤醒时进入可执行状态
4. 当前线程调用某线程`.join（）`时会使当前线程等待某线程执行完毕再结束，底层调用了`wait`，释放锁

### 3. 一个Activity启动另一个Activity的生命周期是什么样的？

答案：onPause -> onCreate -> onStart -> onResume -> onStop

### 4. 隐式Activity过滤信息有哪些？

答案：intentFilter过滤信息有action，category，data。

## Java题

### 1. JVM内存区域划分	

答案：JVM内存可以分为两类：`线程私有区域`和`线程共有区域`

- **线程私有区域**
	- 程序计数器：程序计数器存放的是当前方法的JVM指令地址
	- JVM虚拟机栈：创建线程会创建线程内的虚拟机栈， 栈中存放一个个栈帧，栈帧对应一个个方法调用，其中存放着局部变量表，方法返回值等
	- 本地方法栈：与JVM虚拟机栈类似，不过支持的是Native方法
	
- **线程共有区域**
	- 堆：堆是内存管理核心区域，存放对象实例。所以也是垃圾回收的主要区域，垃圾收集器会对该区域有更细的划分，常见会分为新生代和老生代
	- 方法区：主要存放类结构信息，如静态方法等
	- 常量池：位于方法区中，主要存放各种常量信息

### 2. GC机制

垃圾回收要完成两件事：**找到垃圾**，**回收垃圾**

**找到垃圾**有两种方法：

1. **引用计数法**：当一个对象被引用时，它的引用计数器会加1，垃圾回收时会清理掉引用计数为0的对象。但这种方法并不会回收两个对象相互引用的情况，所以JVM并没有采用这种方法。

2. **可达性分析法**：JVM会选择一些根级对象，从根级对象查找引用关系，回收不再引用中的对象。根级对象一般包括Java虚拟机栈中的对象，本地方法栈中对象，方法区中静态变量和常量池中常亮。

**回收垃圾**有四种方法：

1. **标记清除算法**：该算法分两步，首先标记需要回收的垃圾对象，然后回收这些对象。缺点是会造成内存碎片化。

2. **复制算法**：将存活的对象复制到另一块内存区域中，并整理相应内存。优点是避免内存碎片化，缺点是需要两倍内存。

3. **标记整理算法**：标记需要回收的垃圾对象，清楚垃圾对象后将存活对象压缩。避免内存碎片化。

4. **分代算法**：分代算法将对象分为新生代和老年代，然后针对不同生命周期对象采用不同回收策略，提高GC效率。

	**新生代**有三个区域：`Eden区`和两个`Survivor区` `Eden区`存放新创建的对象，当Eden区内存达到阙值时，触发Minor GC，然后将Eden区存活对象复制到一个Survivor区，同时这些对象存活次数加1，此时Eden区闲置。当Eden再次达到阙值触发Minor GC后，将Eden区存活对象与前一个Survivor区对象复制到另一块Survivor区中，对象存活次数加1。这个过程会持续多次，当对象存活次数达到阙值时，这个对象会晋升到老年代中。新生代采用的是`复制算法`。
	
	**老年代**：老年代存放的都是经过多次GC仍然存活生命周期很长的对象，当老年代内存达到阙值时也会触发Minor GC，采用的是**标记整理算法**
	
### 3. 类加载过程

Java中类加载分三个步骤：**加载**，**链接**，**初始化**

- **加载**：将字节码数据从数据源读到JVM内存，并映射为JVM认可的结构（Class对象）。数据源可以是jar文件，class文件等。若数据格式不是ClassFile的结构，会报ClassForamtError。

- **链接**：	链接是类加载核心，分三个步骤：
	- 验证：JVM校验字节信息是否符合规范，避免恶意信息和不规范信息危害JVM运行安全，是保证JVM安全的重要步骤。校验失败会报VerifyError。
	- 准备：创建静态变量，并为其开辟内存空间。
	- 解析：将符号引用替换为直接饮用。

- **初始化**：为静态变量复制，执行静态代码块。

### 4. 双亲委派模型

类加载器大致分为3类：**启动类加载器**，**扩展类加载器**，**应用程序类加载器**

- 启动类加载器：主要加载`jre/lib`下的`jar`文件
- 扩展类加载器：主要加载`jre/lib/ext`下的`jar`文件
- 应用程序类加载器：主要加载`classpath`下的文件

所谓双亲委派模型，就是在加载一个类时，优先使用父类加载器加载，若父类加载器无法加载，才用子类加载器加载。目的是防止类的重复加载。

### 5. `HashMap`原理

### 6. `volatile`和`synchronize`的区别

`volatitle`原理是在汇编代码中多了一个**lock前缀指令**，这个前缀指令相当于一个内存屏障，**内存屏障**有三个作用：

1. 确保指令重拍时不会把屏障前的指令排在屏障后，不会把屏障后的指令排在屏障前。
2. 修改缓存中的共享变量后立即刷新到主存。
3. 执行写操作时会让其他CPU中的缓存无效。

Java多线程开发中，有三个重要概念：**原子性**，**可见性**，**有序性**。

- **原子性**：一个或多个操作要么都执行，要么都不执行。
- **可见性**：一个线程对共享变量的修改，其他线程立即可见。
- **有序性**：程序执行顺序按照代码顺序执行。为了执行效率，有时候可能会发生**指令重排**。指令重排在多线程中就可能发生问题，`volatitle`在一定程度上可以避免指令重排。

### 7. Java中的线程池

### 8. `	final`、`finally`、`finalize`区别

- **final**：用来修饰类，变量或方法。修饰类表示类不可被继承；修饰变量表示值不可更改；修饰方法表示不可被重写。
- **finally**：是保证重点代码一定执行的一种机制。常见try-finally或try-catch-finally，用来关闭文件流等操作。
- **finalize**：是Object中的方法，设计目的是保证在垃圾回收前完成特定资源回收，已不推荐使用。


### 9. Java中引用类型的区别，具体的使用场景

- **强引用**：通过new创建对象的引用都属于强引用，垃圾回收即使内存不足也不会回收强引用对象。
- **软引用**：通过SoftRefrence实现，在OOM之前，垃圾回收会回收软引用对象。使用场景是存储一些内存敏感的缓存，内存不足时会回收。
- **弱引用**：通过WeakRefrence实现，GC只要扫描到弱引用对象就会回收。使用场景也是一些内存敏感的缓存。
- **虚引用**：通过FanttomRefrence实现，随时可能被回收。如果一个对象只通过虚引用引用，那么无法访问这个对象的任何属性和方法。作用仅仅是保证对象在finalize后，做某些事情。使用场景是跟踪对象被垃圾回收的活动，被虚引用的对象被垃圾回收之前会收到系统通知。


### 10. Exception 和 Error的区别

Exception和Error都继承于`Throwable`类型，只有`Throwable`类型的对象才能被`throw`或`catch`，是异常处理机制的基本组成类型。

- **Exception**：指程序正常运行中，可以预料的情况。分为 checked Exception 和 unchecked Exception。

	- checked Exception：必须进行捕获，是编译器检查的一部分。
	- unchecked Exception：运行时异常，根据需求看是否捕获，编译器不强制要求。常见异常如空指针，数组越界等。

- **Error**：指程序正常情况下，不太可能出现的情况，所以不便也不需要捕获。绝大多数Error都会使程序处于非正常，不可恢复的状态。如`OutOfMemoryError`就是Error的子类。


## 网络题

### 1. `Http`于`Https`的区别

Https可以理解为安全的Http协议。Https主要作用有两点：建立安全的信息传输通道，保障数据传输安全；确认网站真实性。

- Https需要CA申请证书
- Http时明文传输，安全性低；Https数据通过ssl加密过，安全性高。
- Http端口默认80；Https端口默认443。

#### 先说加密算法：
加密算法分两类，对称加密和非对称加密。

- 对称加密：加密和解密用的是相同的密钥。优点是速度快，缺点是安全性低。常见对称加密有DES，AES等。
- 非对称加密：有一个密钥对，分为公钥和私钥。一般私钥自己持有，公钥公开给对方。采用公钥加密的数据只有对应私钥可以解密。优点是安全性高，缺点是效率低。常见非堆成加密有RSA，SHA等。

正式常见一般是对称加密和非对称加密结合使用。先用非对称加密完成密钥的传递，然后使用对称加密对数据进行加密和解密。即保证安全性，又提高了传输效率。

#### Https工作流程：

Https是运行在提供数据加密的安全层TLS（Transport Layer Secure）上的Http。

1. 客户端向服务器发起加密通信请求
	- 支持的协议版本，如TLS1.0
	- 生成随机数random1，稍后用于生成“对话密钥”
	- 支持加密方式，如RSA
	- 支持的压缩方法

2. 服务器收到请求，响应客户端
	- 确认协议版本，如TLS1.0 如果支持版本不一致，关闭加密通信
	- 生成随机数random2，少有用语生成“对话密钥”
	- 确认加密方式，如RSA
	- 服务器CA证书

3. 客户端收到证书进行验证
	- 验证证书安全性
	- 验证通过生成，随机数 pre-master secret，使用证书中的公钥加密，传给服务器

4. 服务器收到数据后，使用私钥解密，获取客户端随机数pre-master secret，然后通过一定的算法，将random1，random2和pre-master secret进行加密，得到一个对称加密的密钥；同时客户端也会使用相同算法对random1，random2和pre-master secret生成相同密钥。

5. 使用上一步生成的对称密钥，对传输的数据进行加密和解密。 

### 2. TCP三次握手流程

## Android题

### 1. Android进程间通信方式（IPC）
AIDL，广播，文件，Socket，管道（pipe）

### 2. Android性能优化工具

- Android Studio自带的**Android Profile**：可以检测三个方面的性能问题：CPU、MEMORY、NETWORK。
- **LeakCanary**：检测运行期间的内存泄漏。
- **BlockCanary**：检测运行期间的UI卡顿。

### 3. Android性能优化
性能优化可以从几个方面来考虑：**内存优化**，**布局优化**，**网络优化**，**安装包优化**。

- **内存优化**：见下一题
- **布局优化**：本质是减少View嵌套层级。常见优化方案：
	- 善用`indlude`标签，重复使用布局.
	- 使用`ViewStub`标签加载不常用布局。
	- 使用`Merge`减少嵌套层次.
	- 推荐多使用**ConstraintLayout**布局，功能非常强大，将大大减少嵌套。
	- 可以使用Android Studio自带的**Layout Inspector**工具检测布局的层级关系，减少无用嵌套。
	
- **网络优化**：
	- 减少网络请求，尽量合并。
	- 大量数据采取分页形式。
	- 网络传输采用GZIP压缩。
	- 加入网络请求缓存，避免频繁请求网络。
	- 上传图片时，必要时压缩图片。
	- 避免DNS解析，查询域名可能会花费上百毫秒时间，且有被劫持风险。可以根据业务需求采用动态更新IP方式，或在IP访问失败时切到域名访问。

- **安装包优化**：减少apk文件体积。常见方法如下：
	- 使用混淆。混淆可以去除无用代码，在一定程度上减少apk体积，但效果微乎其微。
	- 减少应用中不必要的资源文件，如图片，在不影响APP效果情况下尽可能压缩。这种方式有一定效果。
	- 在使用了SO库时，优先保留v7版本的SO库，删除其他版本的SO库。因为2018年以来，v7版本的SO库可以满足市场上绝大多数要求。这种方式减少apk体积十分显著。

### 4. Android内存优化

内存优化要从两点考虑：**防止内存泄漏**，**申请更大内存**。

所谓内存泄漏，本质上就是生命骤起长的对象引用了生命周期短的对象。

#### **常见内存泄漏**：

- **单例模式导致的内存泄漏**。比如一个单例的创建需要Context对象，这时候如果传入了Activity的Context对象，则会让单例对象持有这个Activity的强引用，导致其finish后仍无法回收。

- **静态变量导致的内存泄漏**。静态变量放在方法区中，生命周期非常久。如果在Activity中创建了一个静态变量，创建时需要传入Activity的引用（this），就导致静态变量持有Activity引用，在Activity被finish后就会导致内存泄漏。

- **非静态内部类导致的内存泄漏**。本质是非静态内部类默认持有外部类引用。比如在Activity中使用匿名对象方式创建Handler（匿名对象也属于非静态内部类）。这时Handler对象就会默认持有Activity引用，如果在Handler执行延时任务时finish掉Activity，就会导致内存泄漏。解决方法有两种，一是使用静态内部类，在静态内部类中弱引用Activity。二是在Activity的onDestory中调用`handler.removeCallbacksAndMessages`取消延时事件。

- **使用资源未及时关闭导致内存泄漏**。比如操作各种流未及时关闭，Bitmap没有及时recycle等。

- **使用一些三方库未及时解绑**。比如**EventBus**，在onCreat中注册，需要在onDestory中解绑，因为EventBus其实是单例模式。还有**RxJava**，使用`Timer`操作符做了延时操作后也要注意在onDestoruy中调用`disposable.dispose()`取消操作。

- **属性动画导致的内存泄漏**。比如在动画执行中退出Activity，因为此时View还持有Activity，从而导致内存泄漏。解决办法就是在onDestroy中调用动画的`cancel`方法取消属性动画。

- **WebView导致内存泄漏**。Webview比较特殊，有时即使调用了它的`ondestory`方法，也会导致内存泄漏。解决WebView最好的方法就是让WebView所在的Activity运行在另一个进程，在Activity结束时杀死这个进程即可。比如阿里钉钉就时用此种方式解决的。

#### 申请更大内存

有时应用需要引用一些商用SDK，有的SDK本身就有内存泄漏问题，对于这种使用者无法修改的问题，就只能申请更大的内存了。

申请更大内存有两种方式：

- 在清单文件的Application下添加`largeHeap="true"`属性。

- 同一应用开启多个进程来扩大应用的总内存空间。比如个推的Service就是在另一个进程。

### 5. Binder机制

Binder是Android系统最有特色的跨进程通信方式。

Android是基于Linux内核的移动操作系统，也继承了Linux的跨进程通信方式，比如`Socket`，`管道（pipe）`等，Android选择`Binder`作为主要跨进程通信方式主要考虑了两点：**性能**和**安全**

- **性能**。Linux传统通信如`Socket`或`管道`，在进程间数据传输的时候需要复制两次数据。而`Binder`方式只需要复制一次。所以`Binder`性能优于传统Linux通信。

- **安全**。传统Linux跨进程通信不包含通信双方身份验证，导致一些安全问题。Binder机制自带身份验证，安全性得到提高。

`Binder`基于CS架构，主要有四个组成部分：

1. **Client**:客户端进程。
2. **Service**:服务端进程。
3. **ServiceManager**:提供注册、查询和返回代理服务对象等功能。
4. **Binder驱动**：负责建立进程间的Binder连接，进程间数据交互等底层工作。

`Binder`机制流程：

- `Service`通过`Binder驱动`在`ServiceManager`注册服务。
- `Client`通过`Binder驱动`在`ServiceManager`中查询注册的服务。
- `ServiceManager`通过`inder驱动`返回服务端的代理对象。
- 客户端拿到服务端的代理对象即可进行进程间通信。



